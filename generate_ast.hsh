#simple script to generate expr.gr
let args = std.args()

if std.len(args) != 1 then
    std.print("Usage: generate_ast <output_dir>")
    std.exit(1)
end

let outputDir = args[0]

#--Utility--#

function toLower(string)
    std.trim(${echo $string | tr '[:upper:]' '[:lower:]'}.stdout)
end

function writeLine(path, data)
    {echo $data >> $path}
end

function Type(raw)
    let parts = std.split(raw, ":")
    let fields = []
    let comments = []
    for f in std.iter(std.split(parts[1], ",")) do 
        f = std.trim(f)
        let comment = std.split(f, " ")[0]
        let field = std.split(f, " ")[1]
        std.push(fields, field)
        std.push(comments, comment)
    end
    @[
        name: std.trim(parts[0]),
        fields: fields,
        comments: comments
    ]
end

let variants = []

#--Generators--#

function defineType(path, var)
    let variant = "    " ++ var.name ++ "("
    let comment = "//"
    for i in std.range(0, std.len(var.fields), 1) do
        comment = comment ++ var.comments[i] ++ " "
        variant = variant ++ var.fields[i] ++ ","
    end
    variant = variant ++ "), " ++ comment
    writeLine(path, variant)
end

function defineAst(output, baseName, types)
    let path = output ++ "/" ++ toLower(baseName) ++ ".gr"
    let content = ${cat $path}.stdout
    let re = std.regex("//--end generated content--//")
    if content != "" and re.match(content) then
        content = re.split(content)[1]
    end
    {echo "//Auto generated by generate_ast.hsh" > $path}
    #The output file expects to be in the same directory as the lexer
    writeLine(path, "import { Token } from \"./lexer\"")
    writeLine(path, "export enum " ++ baseName ++ "{")

    for t in std.iter(types) do 
        let variant = Type(t)
        defineType(path, variant)
        std.push(variants, variant)
    end
    writeLine(path, "}")
    writeLine(path, "\n//--end generated content--//")
    if content != "" then
        writeLine(path, content)
    end

end

defineAst(outputDir, "Expr", ["Binary : Left Expr, Operator Token, Right Expr", "Grouping : Group Expr", "Literal: Literal Token", "Unary: Operator Token, Expression Expr"])
